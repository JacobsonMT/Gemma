// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: Gemma Enumeration.vsl in andromda-java-cartridge.
// $Id$
package ubic.gemma.model.genome.biosequence;

/**
 * 
 */
public class SequenceType implements java.io.Serializable, Comparable<SequenceType> {
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = -514928613005922741L;

    /**
     * <p>
     * Represents the target sequence provided by the manufacturer.
     * </p>
     */
    public static final SequenceType AFFY_TARGET = new SequenceType( "AFFY_TARGET" );

    /**
     * <p>
     * Represents a single probe sequence for Affymetrix reporters
     * </p>
     */
    public static final SequenceType AFFY_PROBE = new SequenceType( "AFFY_PROBE" );

    /**
     * 
     */
    public static final SequenceType EST = new SequenceType( "EST" );

    /**
     * 
     */
    public static final SequenceType mRNA = new SequenceType( "mRNA" );

    /**
     * 
     */
    public static final SequenceType REFSEQ = new SequenceType( "REFSEQ" );

    /**
     * 
     */
    public static final SequenceType BAC = new SequenceType( "BAC" );

    /**
     * 
     */
    public static final SequenceType WHOLE_GENOME = new SequenceType( "WHOLE_GENOME" );

    /**
     * 
     */
    public static final SequenceType WHOLE_CHROMOSOME = new SequenceType( "WHOLE_CHROMOSOME" );

    /**
     * <p>
     * Generic DNA sequence of any other type not representable by another value
     * </p>
     */
    public static final SequenceType DNA = new SequenceType( "DNA" );

    /**
     * 
     */
    public static final SequenceType OTHER = new SequenceType( "OTHER" );

    /**
     * 
     */
    public static final SequenceType ORF = new SequenceType( "ORF" );

    /**
     * <p>
     * Represents Affymetrix probe sequences that have been "collapsed" or combined into a single sequence.
     * </p>
     */
    public static final SequenceType AFFY_COLLAPSED = new SequenceType( "AFFY_COLLAPSED" );

    /**
     * <p>
     * Represents a (synthetic) oligonucleotide.
     * </p>
     */
    public static final SequenceType OLIGO = new SequenceType( "OLIGO" );

    private String value;

    private static final java.util.Map<String, SequenceType> values = new java.util.LinkedHashMap<String, SequenceType>(
            13, 1 );

    private static java.util.List<String> literals = new java.util.ArrayList<String>( 13 );

    private static java.util.List<String> names = new java.util.ArrayList<String>( 13 );

    private static java.util.List<SequenceType> valueList = new java.util.ArrayList<SequenceType>( 13 );

    /**
     * Initializes the values.
     */
    static {
        values.put( AFFY_TARGET.value, AFFY_TARGET );
        valueList.add( AFFY_TARGET );
        literals.add( AFFY_TARGET.value );
        names.add( "AFFY_TARGET" );
        values.put( AFFY_PROBE.value, AFFY_PROBE );
        valueList.add( AFFY_PROBE );
        literals.add( AFFY_PROBE.value );
        names.add( "AFFY_PROBE" );
        values.put( EST.value, EST );
        valueList.add( EST );
        literals.add( EST.value );
        names.add( "EST" );
        values.put( mRNA.value, mRNA );
        valueList.add( mRNA );
        literals.add( mRNA.value );
        names.add( "mRNA" );
        values.put( REFSEQ.value, REFSEQ );
        valueList.add( REFSEQ );
        literals.add( REFSEQ.value );
        names.add( "REFSEQ" );
        values.put( BAC.value, BAC );
        valueList.add( BAC );
        literals.add( BAC.value );
        names.add( "BAC" );
        values.put( WHOLE_GENOME.value, WHOLE_GENOME );
        valueList.add( WHOLE_GENOME );
        literals.add( WHOLE_GENOME.value );
        names.add( "WHOLE_GENOME" );
        values.put( WHOLE_CHROMOSOME.value, WHOLE_CHROMOSOME );
        valueList.add( WHOLE_CHROMOSOME );
        literals.add( WHOLE_CHROMOSOME.value );
        names.add( "WHOLE_CHROMOSOME" );
        values.put( DNA.value, DNA );
        valueList.add( DNA );
        literals.add( DNA.value );
        names.add( "DNA" );
        values.put( OTHER.value, OTHER );
        valueList.add( OTHER );
        literals.add( OTHER.value );
        names.add( "OTHER" );
        values.put( ORF.value, ORF );
        valueList.add( ORF );
        literals.add( ORF.value );
        names.add( "ORF" );
        values.put( AFFY_COLLAPSED.value, AFFY_COLLAPSED );
        valueList.add( AFFY_COLLAPSED );
        literals.add( AFFY_COLLAPSED.value );
        names.add( "AFFY_COLLAPSED" );
        values.put( OLIGO.value, OLIGO );
        valueList.add( OLIGO );
        literals.add( OLIGO.value );
        names.add( "OLIGO" );
        valueList = java.util.Collections.unmodifiableList( valueList );
        literals = java.util.Collections.unmodifiableList( literals );
        names = java.util.Collections.unmodifiableList( names );
    }

    /**
     * Creates an instance of SequenceType from <code>value</code>.
     * 
     * @param value the value to create the SequenceType from.
     */
    public static SequenceType fromString( String value ) {
        final SequenceType typeValue = values.get( value );
        if ( typeValue == null ) {
            /*
             * Customization to permit database values to change before code does. Previously this would throw an
             * exception.
             */
            // throw new IllegalArgumentException("invalid value '" + value + "', possible values are: " + literals);
            return null;
        }
        return typeValue;
    }

    /**
     * Returns an unmodifiable list containing the literals that are known by this enumeration.
     * 
     * @return A List containing the actual literals defined by this enumeration, this list can not be modified.
     */
    public static java.util.List<String> literals() {
        return literals;
    }

    /**
     * Returns an unmodifiable list containing the names of the literals that are known by this enumeration.
     * 
     * @return A List containing the actual names of the literals defined by this enumeration, this list can not be
     *         modified.
     */
    public static java.util.List<String> names() {
        return names;
    }

    /**
     * Returns an unmodifiable list containing the actual enumeration instance values.
     * 
     * @return A List containing the actual enumeration instance values.
     */
    public static java.util.List<SequenceType> values() {
        return valueList;
    }

    /**
     * The default constructor allowing super classes to access it.
     */
    protected SequenceType() {
    }

    private SequenceType( String value ) {
        this.value = value;
    }

    /**
     * @see Comparable#compareTo(Object)
     */
    @Override
    public int compareTo( SequenceType that ) {
        return ( this == that ) ? 0 : this.getValue().compareTo( ( that ).getValue() );
    }

    /**
     * @see Object#equals(Object)
     */
    @Override
    public boolean equals( Object object ) {
        return ( this == object )
                || ( object instanceof SequenceType && ( ( SequenceType ) object ).getValue().equals( this.getValue() ) );
    }

    /**
     * Gets the underlying value of this type safe enumeration.
     * 
     * @return the underlying value.
     */
    public String getValue() {
        return this.value;
    }

    /**
     * @see Object#hashCode()
     */
    @Override
    public int hashCode() {
        return this.getValue().hashCode();
    }

    /**
     * @see Object#toString()
     */
    @Override
    public String toString() {
        return String.valueOf( value );
    }

    /**
     * This method allows the deserialization of an instance of this enumeration type to return the actual instance that
     * will be the singleton for the JVM in which the current thread is running.
     * <p>
     * Doing this will allow users to safely use the equality operator <code>==</code> for enumerations because a
     * regular deserialized object is always a newly constructed instance and will therefore never be an existing
     * reference; it is this <code>readResolve()</code> method which will intercept the deserialization process in order
     * to return the proper singleton reference.
     * <p>
     * This method is documented here: <a
     * href="http://java.sun.com/j2se/1.3/docs/guide/serialization/spec/input.doc6.html">Java Object Serialization
     * Specification</a>
     */
    private Object readResolve() {
        return SequenceType.fromString( this.value );
    }
}