/*
 * The Gemma project
 * 
 * Copyright (c) 2006 University of British Columbia
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package edu.columbia.gemma.loader.expression.geo;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import edu.columbia.gemma.common.description.LocalFile;
import edu.columbia.gemma.loader.expression.geo.model.GeoDataset;
import edu.columbia.gemma.loader.expression.geo.model.GeoPlatform;
import edu.columbia.gemma.loader.expression.geo.model.GeoSeries;
import edu.columbia.gemma.loader.loaderutils.Fetcher;
import edu.columbia.gemma.loader.loaderutils.SourceDomainObjectGenerator;

/**
 * Given a GEO data set id: (GDS)
 * <ol>
 * <li>Download and parse GDS file</li>
 * <li>Download and parse the corresponding GSE family file</li>
 * <li>Download and unpack the corresponding raw data files (if present)</li>
 * </ol>
 * <hr>
 * <p>
 * 
 * @author pavlidis
 * @version $Id$
 */
public class GeoDomainObjectGenerator implements SourceDomainObjectGenerator {

    protected static Log log = LogFactory.getLog( GeoDomainObjectGenerator.class.getName() );

    protected Fetcher datasetFetcher;
    protected Fetcher seriesFetcher;
    protected GeoFamilyParser gfp = new GeoFamilyParser();

    private boolean processPlatformsOnly;

    /**
     * 
     *
     */
    public GeoDomainObjectGenerator() {
        intialize();
    }

    /**
     * Clear out any data that was already generated by this Generator.
     */
    public void intialize() {
        try {
            datasetFetcher = new DatasetFetcher();
            seriesFetcher = new SeriesFetcher();
        } catch ( ConfigurationException e ) {
            throw new RuntimeException( e );
        }
        this.gfp = new GeoFamilyParser();
    }

    /**
     * @param geoDataSetAccession
     * @return If processPlatformsOnly is true, a collection of GeoPlatforms. Otherwise a Collection of series (just
     *         one).
     */
    public Collection<Object> generate( String geoDataSetAccession ) {

        // Determine which datasets we actually have to process.
        Collection<String> datasetsToProcess = DatasetCombiner.findGDSforGDS( geoDataSetAccession );

        String seriesAccession = DatasetCombiner.findGSEforGDS( geoDataSetAccession );

        log.info( geoDataSetAccession + " corresponds to " + seriesAccession );

        if ( processPlatformsOnly ) {
            return processSeriesPlatforms( seriesAccession );
        }
        
        GeoSeries series = processSeries( seriesAccession );

        // FIXME put this back.
        // processRawData( series );

        for ( String dataSetAccession : datasetsToProcess ) {

            log.info( "Processing " + dataSetAccession );
            String dataSetPath = fetchDataSetToLocalFile( dataSetAccession );

            try {
                GeoDataset gds = processDataSet( dataSetAccession, dataSetPath );

                series.addDataSet( gds );

            } catch ( IOException e ) {
                throw new RuntimeException( e );
            }
        }

        GeoSampleCorrespondence correspondence = DatasetCombiner.findGSECorrespondence( series );
        series.setSampleCorrespondence( correspondence );

        // have to obey the interface.
        Collection<Object> result = new HashSet<Object>();
        result.add( series );
        return result;

    }

    /**
     * Download and parse a GEO series.
     * 
     * @param seriesAccession
     */
    private GeoSeries processSeries( String seriesAccession ) {
        Collection<LocalFile> fullSeries = seriesFetcher.fetch( seriesAccession );
        if ( fullSeries == null ) {
            throw new RuntimeException( "No series file found for " + seriesAccession );
        }
        LocalFile seriesFile = ( fullSeries.iterator() ).next();
        String seriesPath;
        try {
            seriesPath = ( new URI( seriesFile.getLocalURI() ) ).getPath();
        } catch ( URISyntaxException e ) {
            throw new IllegalStateException( e );
        }
        gfp.setProcessPlatformsOnly( this.processPlatformsOnly );
        try {
            gfp.parse( seriesPath );
        } catch ( IOException e1 ) {
            throw new RuntimeException( e1 );
        }

        return ( ( GeoParseResult ) gfp.getResults().iterator().next() ).getSeriesMap().get( seriesAccession );

    }

    /**
     * Download and parse a GEO platform using a series accession.
     * 
     * @param seriesAccession
     */
    private Collection processSeriesPlatforms( String seriesAccession ) {
        Collection<LocalFile> fullSeries = seriesFetcher.fetch( seriesAccession );
        if ( fullSeries == null ) {
            throw new RuntimeException( "No series file found for " + seriesAccession );
        }
        LocalFile seriesFile = ( fullSeries.iterator() ).next();
        String seriesPath;
        try {
            seriesPath = ( new URI( seriesFile.getLocalURI() ) ).getPath();
        } catch ( URISyntaxException e ) {
            throw new IllegalStateException( e );
        }
        gfp.setProcessPlatformsOnly( this.processPlatformsOnly );
        try {
            gfp.parse( seriesPath );
        } catch ( IOException e1 ) {
            throw new RuntimeException( e1 );
        }

        return ( ( GeoParseResult ) gfp.getResults().iterator().next() ).getPlatformMap().values();

    }

    /**
     * Parse a GEO GDS file, return the extracted GeoDataset.
     * 
     * @param geoDataSetAccession
     * @param dataSetPath
     * @return GeoDataset
     * @throws IOException
     */
    private GeoDataset processDataSet( String geoDataSetAccession, String dataSetPath ) throws IOException {
        gfp.parse( dataSetPath );

        GeoParseResult results = ( GeoParseResult ) gfp.getResults().iterator().next(); // first result is where
        // we
        // start.

        Map<String, GeoDataset> datasetMap = results.getDatasets();
        if ( !datasetMap.containsKey( geoDataSetAccession ) ) {
            throw new IllegalStateException( "Failed to get parse of " + geoDataSetAccession );
        }

        GeoDataset gds = datasetMap.get( geoDataSetAccession );
        return gds;
    }

    /**
     * @param geoDataSetAccession
     * @return
     */
    private String fetchDataSetToLocalFile( String geoDataSetAccession ) {
        Collection<LocalFile> result = datasetFetcher.fetch( geoDataSetAccession );

        if ( result == null ) return null;

        if ( result.size() != 1 ) {
            throw new IllegalStateException( "Got " + result.size() + " files for " + geoDataSetAccession
                    + ", expected only one." );
        }

        LocalFile dataSetFile = ( result.iterator() ).next();
        String dataSetPath;
        try {
            dataSetPath = ( new URI( dataSetFile.getLocalURI() ) ).getPath();
        } catch ( URISyntaxException e ) {
            throw new IllegalStateException( e );
        }
        return dataSetPath;
    }

    /**
     * Fetch any raw data files
     * 
     * @param series
     */
    private void processRawData( GeoSeries series ) {
        RawDataFetcher rawFetcher = new RawDataFetcher();
        Collection<LocalFile> rawFiles = rawFetcher.fetch( series.getGeoAccession() );
        if ( rawFiles != null ) {
            // FIXME maybe do something more. These are usually (always?) CEL files so they can be parsed and
            // assembled or left alone.
            log.info( "Downloaded raw data files" );
        }
    }

    /**
     * @param datasetFetcher The datasetFetcher to set.
     */
    public void setDatasetFetcher( Fetcher df ) {
        this.datasetFetcher = df;
    }

    /**
     * @param seriesFetcher The seriesFetcher to set.
     */
    public void setSeriesFetcher( Fetcher seriesFetcher ) {
        this.seriesFetcher = seriesFetcher;
    }

    /**
     * @param b
     */
    public void setProcessPlatformsOnly( boolean b ) {
        this.processPlatformsOnly = b;
    }

}
